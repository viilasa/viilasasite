"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[13],{4013:function(e,n,t){t.r(n),t.d(n,{default:function(){return d}});var i=t(7437),o=t(2265),r=t(8766),l=t(1062),a=t(7422);let u={black:"#000000",white:"#ffffff",red:"#ff0000",green:"#00ff00",blue:"#0000ff",fuchsia:"#ff00ff",cyan:"#00ffff",yellow:"#ffff00",orange:"#ff8000"};function s(e){4===e.length&&(e=e[0]+e[1]+e[1]+e[2]+e[2]+e[3]+e[3]);let n=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return n||console.warn(`Unable to convert hex string ${e} to rgb values`),[parseInt(n[1],16)/255,parseInt(n[2],16)/255,parseInt(n[3],16)/255]}function c(e){if(void 0===e)return[0,0,0];if(3==arguments.length)return arguments;if(!isNaN(e)){var n;return[((n=parseInt(n=e))>>16&255)/255,(n>>8&255)/255,(255&n)/255]}return"#"===e[0]?s(e):u[e.toLowerCase()]?s(u[e.toLowerCase()]):(console.warn("Color format not recognised"),[0,0,0])}class f extends Array{constructor(e){if(Array.isArray(e))return super(...e);return super(...c(...arguments))}get r(){return this[0]}get g(){return this[1]}get b(){return this[2]}set r(e){this[0]=e}set g(e){this[1]=e}set b(e){this[2]=e}set(e){return Array.isArray(e)?this.copy(e):this.copy(c(...arguments))}copy(e){return this[0]=e[0],this[1]=e[1],this[2]=e[2],this}}var m=t(7373),d=e=>{let{color:n=[1,1,1],amplitude:t=1,distance:u=0,enableMouseInteraction:s=!1,quality:c="high",targetFPS:d,mobileTargetFPS:_,...v}=e,p=(0,o.useRef)(null),h=(0,o.useRef)(),x=(0,o.useRef)(null),b=(0,o.useRef)(null),g=(0,o.useRef)(null),y=(0,o.useRef)(!1);return(0,o.useEffect)(()=>{if(!p.current)return;let e=p.current,i=()=>window.innerWidth<768;y.current=i();let o=null!=d?d:60;y.current&&(o=null!=_?_:40),"medium"===c?o=Math.max(30,.85*o):"low"===c&&(o=Math.max(25,.65*o));let v=1e3/o,w=new r.T({dpr:Math.min(window.devicePixelRatio,"low"===c?1:1.5),alpha:!0,antialias:!1});b.current=w;let P=w.gl;P.clearColor(0,0,0,0),P.enable(P.BLEND),P.blendFunc(P.SRC_ALPHA,P.ONE_MINUS_SRC_ALPHA),e.appendChild(P.canvas);let R=new l.C(P),C=new a.$(P,{vertex:"\n  attribute vec2 position;\n  attribute vec2 uv;\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = vec4(position, 0.0, 1.0);\n  }\n",fragment:"\n  precision highp float; // Keep highp for now, test mediump if needed\n\n  uniform float iTime;\n  uniform vec3 iResolution;\n  uniform vec3 uColor;\n  uniform float uAmplitude;\n  uniform float uDistance;\n  uniform vec2 uMouse;\n  uniform float uIsMobile; // New uniform: 1.0 for mobile, 0.0 otherwise\n\n  #define PI 3.1415926538\n\n  const int u_line_count_max = 40; // Max lines (original count)\n  const float u_line_width = 7.0;\n  const float u_line_blur = 10.0;\n\n  float pixel(float count, vec2 resolution) {\n      return 1.0 / max(resolution.x, resolution.y) * count;\n  }\n\n  // Perlin Noise function (unchanged)\n  float Perlin2D(vec2 P)\n  {\n      // ... (Perlin noise code remains the same) ...\n      vec2 Pi = floor(P);\n      vec4 Pf_Pfmin1 = P.xyxy - vec4(Pi, Pi + 1.0);\n      vec4 Pt = vec4(Pi.xy, Pi.xy + 1.0);\n      Pt = Pt - floor(Pt * (1.0 / 71.0)) * 71.0;\n      Pt += vec2(26.0, 161.0).xyxy;\n      Pt *= Pt;\n      Pt = Pt.xzxz * Pt.yyww;\n      vec4 hash_x = fract(Pt * (1.0 / 951.135664));\n      vec4 hash_y = fract(Pt * (1.0 / 642.949883));\n      vec4 grad_x = hash_x - 0.49999;\n      vec4 grad_y = hash_y - 0.49999;\n      vec4 grad_results = inversesqrt(grad_x * grad_x + grad_y * grad_y) * (grad_x * Pf_Pfmin1.xzxz + grad_y * Pf_Pfmin1.yyww);\n      grad_results *= 1.4142135623730950488016887242097;\n      vec2 blend = Pf_Pfmin1.xy * Pf_Pfmin1.xy * Pf_Pfmin1.xy * (Pf_Pfmin1.xy * (Pf_Pfmin1.xy * 6.0 - 15.0) + 10.0);\n      vec4 blend2 = vec4(blend, vec2(1.0 - blend));\n      return dot(grad_results, blend2.zxzx * blend2.wwyy);\n  }\n\n  // Line drawing function with mobile optimizations\n  float line(vec2 st, float width, float perc, float offset, float mobile_amplitude_factor) {\n      float split_offset = (perc * 0.4);\n      float split_point = 0.1 + split_offset;\n\n      float amplitude_normal = smoothstep(split_point, 0.7, st.x);\n      // Apply mobile factor here if needed, or adjust base amplitude\n      float amplitude_strength = 0.5 * mobile_amplitude_factor;\n      float amplitude = amplitude_normal * amplitude_strength * uAmplitude * (1.0 + (uMouse.y - 0.5) * 0.2);\n\n      float time_scaled = iTime / 10.0 + (uMouse.x - 0.5) * 1.0;\n\n      float blur = smoothstep(split_point, split_point + 0.05, st.x) * perc;\n\n      float xnoise;\n      // --- Mobile Optimization ---\n      if (uIsMobile > 0.5) {\n           // Simpler noise calculation for mobile\n           xnoise = Perlin2D(vec2(time_scaled, st.x + perc) * 2.0); // Reduced frequency/complexity\n           amplitude *= 0.8; // Optionally reduce amplitude further on mobile\n      } else {\n           // Original noise calculation for desktop\n           xnoise = mix(\n               Perlin2D(vec2(time_scaled, st.x + perc) * 2.5),\n               Perlin2D(vec2(time_scaled, st.x + time_scaled) * 3.5) / 1.5,\n               st.x * 0.3\n           );\n      }\n      // --- End Mobile Optimization ---\n\n      float y = 0.5 + (perc - 0.5) * uDistance + xnoise / 2.0 * amplitude;\n\n      float line_start = smoothstep(\n          y + (width / 2.0) + (u_line_blur * pixel(1.0, iResolution.xy) * blur),\n          y,\n          st.y\n      );\n\n      float line_end = smoothstep(\n          y,\n          y - (width / 2.0) - (u_line_blur * pixel(1.0, iResolution.xy) * blur),\n          st.y\n      );\n\n      return clamp(\n          (line_start - line_end) * (1.0 - smoothstep(0.0, 1.0, pow(perc, 0.3))),\n          0.0,\n          1.0\n      );\n  }\n\n  void mainImage( out vec4 fragColor, in vec2 fragCoord )\n  {\n      vec2 uv = fragCoord / iResolution.xy;\n\n      float line_strength = 1.0;\n      float line_count = float(u_line_count_max); // Start with max\n      float mobile_factor = 1.0; // Factor for adjustments\n      float mobile_amplitude_factor = 1.0; // Factor for amplitude adjustments\n\n      // Adjust line count and potentially other factors based on resolution and uIsMobile\n      if (uIsMobile > 0.5) {\n          // Base mobile adjustments (more aggressive reduction)\n          mobile_factor = 0.6;\n          mobile_amplitude_factor = 0.8; // Slightly less amplitude on mobile base\n\n          if (iResolution.x < 768.0) { // Medium mobile screen\n              mobile_factor = 0.5; // Further reduce lines\n          }\n          if (iResolution.x < 480.0) { // Small mobile screen\n              mobile_factor = 0.4; // Reduce lines significantly\n              mobile_amplitude_factor = 0.7; // Reduce amplitude more\n          }\n           line_count = float(u_line_count_max) * mobile_factor;\n      } else {\n           // Optional non-mobile adjustments (could be removed if not needed)\n           if (iResolution.x < 768.0) {\n               // Less aggressive reduction for small non-mobile windows\n               // mobile_factor = 0.8;\n               // line_count = float(u_line_count_max) * mobile_factor;\n           }\n      }\n\n\n      // Adjust line width scaling based on screen size (more pronounced on smaller screens)\n      float scale = 1.0;\n      if (iResolution.x < 768.0) scale = 1.5;\n      if (iResolution.x < 480.0) scale = 2.0;\n\n\n      // Loop up to the original max count, but break early based on calculated line_count\n      for (int i = 0; i < u_line_count_max; i++) {\n          if (float(i) >= line_count) break; // Exit loop early if fewer lines are needed\n\n          // Calculate percentage based on the original max count for smoother distribution/appearance\n          float perc = float(i) / float(u_line_count_max - 1); // Normalize 0 to 1 based on max count\n\n          // Pass mobile amplitude factor to line function\n          line_strength *= (1.0 - line(\n              uv,\n              // Adjust width based on scale and make lines thinner towards the edges\n              u_line_width * pixel(1.0, iResolution.xy) * scale * (1.0 - perc),\n              perc,\n              (PI * 1.0) * perc, // Offset based on percentage\n              mobile_amplitude_factor\n          ));\n      }\n\n      float color_intensity = 1.0 - line_strength;\n      fragColor = vec4(uColor * color_intensity, color_intensity);\n  }\n\n  void main() {\n      mainImage(gl_FragColor, gl_FragCoord.xy);\n  }\n",uniforms:{iTime:{value:0},iResolution:{value:new f(P.canvas.width,P.canvas.height,P.canvas.width/P.canvas.height)},uColor:{value:new f(...n)},uAmplitude:{value:t},uDistance:{value:u},uMouse:{value:new Float32Array([.5,.5])},uIsMobile:{value:y.current?1:0}}});g.current=C;let M=new m.K(P,{geometry:R,program:C});function A(){if(!e||!b.current||!g.current)return;let{clientWidth:n,clientHeight:t}=e;y.current=i(),g.current.uniforms.uIsMobile.value=y.current?1:0,b.current.setSize(n,t),g.current.uniforms.iResolution.value.set(n,t,n/t)}x.current=new ResizeObserver(A),x.current.observe(e);let E=[.5,.5],I=[.5,.5],L=!0,z=new IntersectionObserver(e=>{L=e[0].isIntersecting},{threshold:.1});function F(n){if(!L||!e)return;let t=e.getBoundingClientRect(),i=("touches"in n?n.touches[0].clientX:n.clientX)-t.left,o=("touches"in n?n.touches[0].clientY:n.clientY)-t.top;I=[Math.max(0,Math.min(1,i/t.width)),Math.max(0,Math.min(1,1-o/t.height))]}function N(){I=[.5,.5]}z.observe(e),s&&(e.addEventListener("mousemove",F,{passive:!0}),e.addEventListener("touchmove",F,{passive:!0}),e.addEventListener("mouseleave",N),e.addEventListener("touchend",N));let k=0;return A(),h.current=requestAnimationFrame(function e(n){if(!b.current||!g.current||!L){h.current=requestAnimationFrame(e);return}let t=n-k;if(t<v){h.current=requestAnimationFrame(e);return}k=n-t%v,s&&(E[0]+=.05*(I[0]-E[0]),E[1]+=.05*(I[1]-E[1]),g.current.uniforms.uMouse.value[0]=E[0],g.current.uniforms.uMouse.value[1]=E[1]),g.current.uniforms.iTime.value=.001*n,b.current.render({scene:M}),h.current=requestAnimationFrame(e)}),()=>{if(h.current&&cancelAnimationFrame(h.current),x.current&&x.current.disconnect(),z.disconnect(),s&&e&&(e.removeEventListener("mousemove",F),e.removeEventListener("touchmove",F),e.removeEventListener("mouseleave",N),e.removeEventListener("touchend",N)),b.current&&e){var n;let t=b.current.gl;null===(n=t.getExtension("WEBGL_lose_context"))||void 0===n||n.loseContext(),e.contains(t.canvas)&&e.removeChild(t.canvas)}b.current=null,g.current=null}},[n,t,u,s,c,d,_]),(0,i.jsx)("div",{ref:p,className:"w-full h-full relative touch-none select-none",style:{WebkitTapHighlightColor:"transparent"},...v})}}}]);